<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go on /home/lunarxlark/.config/blog</title><link>https://lunarxlark.github.io/tags/go/</link><description>Recent content in go on /home/lunarxlark/.config/blog</description><generator>Hugo -- gohugo.io</generator><copyright>© lunarxlark</copyright><lastBuildDate>Thu, 11 Mar 2021 03:08:11 +0900</lastBuildDate><atom:link href="https://lunarxlark.github.io/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>load test with dynamic payload by tsenart/vegeta</title><link>https://lunarxlark.github.io/posts/go/vegeta-dynamic-payload/</link><pubDate>Thu, 11 Mar 2021 03:08:11 +0900</pubDate><guid>https://lunarxlark.github.io/posts/go/vegeta-dynamic-payload/</guid><description>負荷テストツールvegetaのコマンドでの使い方ぐはググるとたくさん出てくるが、ライブラリとして仕様している記事が少なく手こずったのでメモ代わりに記事にする。
やりたいこと リクエスト毎にRequestの内容を動的に変えて、負荷をかけたかった。
Headerに持つタイムスタンプがリクエスト時のタイムスタンプになるように。 userIdはuniqueになるように。(同じユーザだと重複リクエストを弾く処理があったため。) 具体的には下記のような感じでリクエストを送りたい。
{&amp;#34;header&amp;#34;: {&amp;#34;timestamp&amp;#34;:&amp;#34;1234&amp;#34;}, &amp;#34;body&amp;#34;: {&amp;#34;userId&amp;#34;: &amp;#34;lunar-1&amp;#34;}} {&amp;#34;header&amp;#34;: {&amp;#34;timestamp&amp;#34;:&amp;#34;1234&amp;#34;}, &amp;#34;body&amp;#34;: {&amp;#34;userId&amp;#34;: &amp;#34;lunar-2&amp;#34;}} {&amp;#34;header&amp;#34;: {&amp;#34;timestamp&amp;#34;:&amp;#34;1235&amp;#34;}, &amp;#34;body&amp;#34;: {&amp;#34;userId&amp;#34;: &amp;#34;lunar-3&amp;#34;}} ... {&amp;#34;header&amp;#34;: {&amp;#34;timestamp&amp;#34;:&amp;#34;1240&amp;#34;}, &amp;#34;body&amp;#34;: {&amp;#34;userId&amp;#34;: &amp;#34;lunar-n&amp;#34;}} vegeta.Targeterは func(*vegeta.Target) error である。
また、vegeta.Attackは、vegeta.Targeterをgoroutineで都度呼び出して、Targeter内からTargetに基づきリクエストしていることから、都度Targetが変わるようなTargeterを返す関数を作成し、それをAttack時に呼び出せば良さそう。
ってことが、 [QUESTION] Sending requests with dynamic body #330に書いてあって何度も行き来した結果やっと理解できた&amp;hellip;。
上記を拝借して以下のようにすることで目的を達成できた。
type yourRequestBody struct { UserID string } targeter := func(id uint64) vegeta.Targeter { return func(t *vegeta.Target) error { execTime := time.Now() requestTimestamp := execTime.Unix() req := &amp;amp;http.Request{ Method: &amp;#34;POST&amp;#34;, URL: &amp;amp;url.</description></item><item><title>Custome Logger using LoggerWithConfig in Echo</title><link>https://lunarxlark.github.io/posts/go/echo-custom-logger/</link><pubDate>Tue, 10 Nov 2020 02:51:09 +0900</pubDate><guid>https://lunarxlark.github.io/posts/go/echo-custom-logger/</guid><description>WebFramework EchoのLoggerを弄っていて気付いた点があったのでメモ。
sample code
箇条書き responseログにHeader X-Any-Headerを出力したい場合、ログフォーマットに&amp;quot;any_header&amp;quot;:${header:x-any-header}を指定すればいいよ responseログにQueryParamerter ?anyparam=xxxを出力したい場合、ログフォーマットに&amp;quot;any_query&amp;quot;:${query:anyparam}を指定すればいいよ デフォルトで出力されるカラム&amp;rsquo;id&amp;rsquo;はHeader X-Request-Id を指定すると出力されるよ Skipperを設定することで、path毎にログ出力する/しない等を設定出来るよ 1, 2, 3はEchoのそういう機能だってことで特にありません。 4は結構便利だなと思いました。以下のサンプルコードでは、/healthcheckに来た場合とCI/CD等での自動テスト時にはresponseログを出力しないようにする設定例です。
sample // Middleware e.Use(middleware.LoggerWithConfig(customLogger())) // Handler e.GET(&amp;#34;/greet&amp;#34;, greet) e.GET(&amp;#34;/healthcheck&amp;#34;, healthcheck) var ResponseLogForamt = `{` + `&amp;#34;time&amp;#34;:&amp;#34;${time_custom}&amp;#34;,` + `&amp;#34;id&amp;#34;:&amp;#34;${id}&amp;#34;,` + `&amp;#34;remote_ip&amp;#34;:&amp;#34;${remote_ip}&amp;#34;,` + `&amp;#34;host&amp;#34;:&amp;#34;${host}&amp;#34;,` + `&amp;#34;method&amp;#34;:&amp;#34;${method}&amp;#34;,` + `&amp;#34;uri&amp;#34;:&amp;#34;${uri}&amp;#34;,` + `&amp;#34;user_agent&amp;#34;:&amp;#34;${user_agent}&amp;#34;,` + `&amp;#34;status&amp;#34;:${status},` + `&amp;#34;error&amp;#34;:&amp;#34;${error}&amp;#34;,` + `&amp;#34;latency&amp;#34;:${latency},` + `&amp;#34;latency_human&amp;#34;:&amp;#34;${latency_human}&amp;#34;,` + `&amp;#34;bytes_in&amp;#34;:${bytes_in},` + `&amp;#34;bytes_out&amp;#34;:${bytes_out},` + `&amp;#34;forwarded-for&amp;#34;:&amp;#34;${header:x-forwarded-for}&amp;#34;,` + `&amp;#34;same-as-id&amp;#34;:${header:X-Request-Id},` + `&amp;#34;query&amp;#34;:${query:lang}` + `}` func customLogger() middleware.LoggerConfig { cl := middleware.</description></item><item><title>Go Module</title><link>https://lunarxlark.github.io/posts/go/go-module/</link><pubDate>Thu, 14 May 2020 01:12:54 +0900</pubDate><guid>https://lunarxlark.github.io/posts/go/go-module/</guid><description>&lt;p>(この記事は、執筆時点での&lt;a href="https://github.com/golang/go/wiki/Modules">Go Modules&lt;/a>をもとにした私のメモです。Go Moduleの理解のために、元記事と記載の順番が入れ替わっている項目もあります。)&lt;/p></description></item><item><title>My Favorite Usage urfave/cli</title><link>https://lunarxlark.github.io/posts/go/my-favorite-usage-urfave-cli/</link><pubDate>Thu, 06 Feb 2020 02:47:11 +0900</pubDate><guid>https://lunarxlark.github.io/posts/go/my-favorite-usage-urfave-cli/</guid><description>&lt;p>参加しているプロジェクトで&lt;code>urfave/cli&lt;/code>を使っている。使い方は&lt;a href="https://github.com/urfave/cli/blob/master/docs/v2/manual.md#examples">Example&lt;/a>にあるのと同じ書き方で使っている。
大半のバッチ処理をコマンドとして記述しているので、Exampleの書き方だとだいぶ見辛くなってきた。縦長のコマンド定義とオプション説明で目的の処理を探すのにもページ送りを何度もする。なんとかしたい。&lt;/p></description></item><item><title>Error 'undefined' when go run</title><link>https://lunarxlark.github.io/posts/go/how-to-go-run/</link><pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate><guid>https://lunarxlark.github.io/posts/go/how-to-go-run/</guid><description>x…motemen/ghqを写経している時、 go run main.go 出来ないことに気付いた。 下記が実行時のエラーになる。ちなみに、 go build は出来る。
~/d/s/g/x/ghq &amp;gt;&amp;gt;&amp;gt; go run main.go # command-line-arguments ./main.go:38:17: undefined: commands ~/d/s/g/x/ghq &amp;gt;&amp;gt;&amp;gt; commands が見つからない？同じ階層の commands.go には下記記述がちゃんとあるのに、どうして見つからない&amp;hellip;。
var commands = []*cli.Command{ commandGet, commandList, commandRoot, commandCreate, } 理由は、go runの引数に指定したファイル(+ importされるパッケージ)しか読み込まないから。
実際、go run main.go commands.goに変更すると上記エラーは解消される&amp;hellip;が、別のエラーとなる。 今度は違うのが見つからないって言われる。
~/d/s/g/x/ghq master &amp;gt;&amp;gt;&amp;gt; go run main.go commands.go # command-line-arguments ./commands.go:25:10: undefined: doGet ./commands.go:50:10: undefined: doList ./commands.go:62:10: undefined: doRoot ./commands.go:71:10: undefined: doCreate 同じ階層で必要なファイルを引数に全て指定すればいいのだけど、そんなことはしたくない。 正規表現で指定してもいいけど、_test.goがあるとgo runで実行出来ないってエラーになる。
~/d/s/g/x/ghq master &amp;gt;&amp;gt;&amp;gt; go run *.</description></item></channel></rss>