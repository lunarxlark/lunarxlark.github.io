<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>go on /home/lunarxlark/.config/blog</title>
    <link>https://lunarxlark.github.io/tags/go/</link>
    <description>Recent content in go on /home/lunarxlark/.config/blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Wed, 24 Nov 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://lunarxlark.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Neovim &#43; DAP &#43; Go</title>
      <link>https://lunarxlark.github.io/articles/20211124_nvim-dap-go/</link>
      <pubDate>Wed, 24 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20211124_nvim-dap-go/</guid>
      <description>TL;DR DAP(Debug Adapter Protocol)の力を借りれば、Neovim上でも視覚的にGoのデバッグが出来ました。 ここでは下記については話しません。
DAPの詳細 packer.nvimでのインストール方法 vscode-goのdebugAdapter.jsの使用方法 Neovimでデバッグするモチベーション v0.2.2から色々変わったNeovimを久々に触ってみようかと思いinit.luaへ以降して遊んでいました。 起動が早いだけでなく、LSP系の動作もサクサク動いてここ2ヶ月程快適に過ごしています。
ただ、VSCodeでのデバッグ機能がとても便利なため、デバッガ使用時のみこの快適な環境を離れていました。
どうにかNeovim上で完結させられないか&amp;hellip;。
DAP DAPの説明はリンク先や他HPをご参照ください。
イメージを持ってもらうためLSPを引き合いに出すと、LSPがテキスト編集時に定義や変更内容や補完候補等を返すのに対して、DAPはデバッガとやりとりしてデバッグ情報を返す位のイメージを持ってもらえれば大丈夫だと思います。
Neovim + DAP + Go 使うプラグインは下記になります。
mfussenegger/nvim-dap : NeovimのDAPクライアント。VSCodeのlaunch.jsonも使用可 rcarriga/nvim-dap-ui : nvim-dapを視覚的に操作しやすいUI leoluz/nvim-dap-go : DAPのGo用設定(delve dap起動) nvim-treesitter/nvim-treesitter nvim-dap-goでテストをデバッグする際、近くのテストを見つけるのに必要 packer.nvimの設定 VSCodeのlaunch.jsonを使用しない場合、require(&#39;dap.ext.vscode&#39;).load_launchjs()は不要です。 launch.jsonを読み込めた場合、デバッグ方法の選択時にlaunch.jsonの内容が追加表示されて選択可能になります。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 -- dap plugin installation with packer.nvim ... -- dap use { &amp;#34;rcarriga/nvim-dap-ui&amp;#34;, requires = { &amp;#34;mfussenegger/nvim-dap&amp;#34;, &amp;#34;leoluz/nvim-dap-go&amp;#34;, &amp;#34;nvim-treesitter/nvim-treesitter&amp;#34; }, config = function () vim.</description>
    </item>
    
    <item>
      <title>gin &#43; gorm v2でのセッションやトランザクション</title>
      <link>https://lunarxlark.github.io/articles/20210912_gin_gormv2/</link>
      <pubDate>Sun, 12 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20210912_gin_gormv2/</guid>
      <description>TL;DR ginでの各リクエストを1セッションで管理しつつ、トランザクションも管理したい。
ginのmiddlewareで、gin.Contextにgorm.WithContextを用いてGormのセッションを持たせる。 ginの各HandlerFuncの中では、gin.Context内のGormセッションからDBへアクセスする。 モチベーション Gormはv2になり色々と変わった。 Gorm 2.0 Release Note
色々な記事が書かれているがTransactoinに関してあまり書かれていない。
下記疑問を払拭して正しい使い方を自分なりに確かめたかったので試した。
なんとなく動くがこれで正しいのか? ドキュメントを読んでいてSkipDefaultTransaction:trueだと30%もパフォーマンスが上がるというがその設定はtrueにしていいいのか? っていうか、DefaultTransactionって何？ロールバックの単位とかどうやって指定するの? 確認&amp;amp;検証 検証時に作成したソースはgithub.com/lunarxlark/gorm2-tx
Context Gorm 2.0 #Context
GormはContextサポートを提供し、それを使いたかったらWithContext使ってくれ。 また、Sessionには単セッションモードと継続セッションモードがある。 普通は、継続セッションモードを使って、複数オペレーションをまとめるよ。 &amp;hellip;GormのSessionってどんなことできるの?
Session Gorm 2.0 #Session
Gormは`Session`メソッドをを通して、新しいセッションを提供するよ。 新しいセッションを作る場合、設定がたくさんあるよ。DryRunやLoggerとかね。 &amp;hellip;新しいセッションを一々作るのは望んでない。
Contextサポートしてくれるってことなのでgin.Contextへ埋め込む時にセッションを作成してそれを使い回したい。
gorm.WithContextのreturnはdb.Sessionとなっている(下記はgormのソースから抜粋)ので、gin.Contextへ埋め込むだけで新たにセッションを作る必要はない。
1 2 3 4 // WithContext change current instance db&amp;#39;s context to ctx func (db *DB) WithContext(ctx context.Context) *DB { return db.Session(&amp;amp;Session{Context: ctx}) } ここまでで下記みたいな感じになる。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 func main() { //.</description>
    </item>
    
    <item>
      <title>2021年版 vim &#43; goplsの設定</title>
      <link>https://lunarxlark.github.io/articles/20210616_2021vim_gopls/</link>
      <pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20210616_2021vim_gopls/</guid>
      <description>goplsが出てから, vimでも定義ジャンプやシンボル検索、ドキュメント参照等が行えるようになった。
たまにVSCodeを触りvimでの作業を改善できないか考える中で、自身の設定が古いことに気付いた。また、ググってもなかなか出てこなかったのでメモとして記述する。
cf. GitHub dotfiles
いきなりだが、vimrcとvim-lsp-settings/settings.jsonを抜粋して貼り付ける。
以前、GoではLspCodeAction, LspCodeLens等をサポートしていなかったが、今では使えるようになっている。
キーマップに設定している関数は全てGoで使用出来る。
ただし、カーソルがどこにいても実行出来るわけではないので注意が必要。
LspCodeActionはカーソルの位置によって実行内容が変わるのでそこも注意。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 ... Plug &amp;#39;prabirshrestha/vim-lsp&amp;#39; Plug &amp;#39;mattn/vim-lsp-settings&amp;#39; Plug &amp;#39;prabirshrestha/asyncomplete-lsp.vim&amp;#39; Plug &amp;#39;mattn/vim-gomod&amp;#39; ... &amp;#34; ------------------------------------------------------------------------------ &amp;#34; vim-lsp &amp;#34; ------------------------------------------------------------------------------ function! s:on_lsp_buffer_enabled() abort setlocal omnifunc=lsp#complete setlocal signcolumn=yes if exists(&amp;#39;+tagfunc&amp;#39;) | setlocal tagfunc=lsp#tagfunc | endif nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;ac &amp;lt;plug&amp;gt;(lsp-code-action) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;cl &amp;lt;plug&amp;gt;(lsp-code-lens) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;df &amp;lt;plug&amp;gt;(lsp-definition) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;dd &amp;lt;plug&amp;gt;(lsp-document-diagnostics) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;im &amp;lt;plug&amp;gt;(lsp-implementation) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;pdf &amp;lt;plug&amp;gt;(lsp-peek-definition) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;sm &amp;lt;plug&amp;gt;(lsp-document-symbol-search) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;Sm &amp;lt;plug&amp;gt;(lsp-workspace-symbol-search) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;rf &amp;lt;plug&amp;gt;(lsp-references) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;td &amp;lt;plug&amp;gt;(lsp-type-definition) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;rn &amp;lt;plug&amp;gt;(lsp-rename) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;en &amp;lt;plug&amp;gt;(lsp-next-error) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;ep &amp;lt;plug&amp;gt;(lsp-previous-error) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;ho &amp;lt;plug&amp;gt;(lsp-hover) let g:lsp_format_sync_timeout = 500 autocmd!</description>
    </item>
    
    <item>
      <title>load test with dynamic payload by tsenart/vegeta</title>
      <link>https://lunarxlark.github.io/articles/20210311_vegeta-dynamic-payload/</link>
      <pubDate>Thu, 11 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20210311_vegeta-dynamic-payload/</guid>
      <description>負荷テストツールvegetaのコマンドでの使い方ぐはググるとたくさん出てくるが、ライブラリとして仕様している記事が少なく手こずったのでメモ代わりに記事にする。
やりたいこと リクエスト毎にRequestの内容を動的に変えて、負荷をかけたかった。
Headerに持つタイムスタンプがリクエスト時のタイムスタンプになるように。 userIdはuniqueになるように。(同じユーザだと重複リクエストを弾く処理があったため。) 具体的には下記のような感じでリクエストを送りたい。
1 2 3 4 5 {&amp;#34;header&amp;#34;: {&amp;#34;timestamp&amp;#34;:&amp;#34;1234&amp;#34;}, &amp;#34;body&amp;#34;: {&amp;#34;userId&amp;#34;: &amp;#34;lunar-1&amp;#34;}} {&amp;#34;header&amp;#34;: {&amp;#34;timestamp&amp;#34;:&amp;#34;1234&amp;#34;}, &amp;#34;body&amp;#34;: {&amp;#34;userId&amp;#34;: &amp;#34;lunar-2&amp;#34;}} {&amp;#34;header&amp;#34;: {&amp;#34;timestamp&amp;#34;:&amp;#34;1235&amp;#34;}, &amp;#34;body&amp;#34;: {&amp;#34;userId&amp;#34;: &amp;#34;lunar-3&amp;#34;}} ... {&amp;#34;header&amp;#34;: {&amp;#34;timestamp&amp;#34;:&amp;#34;1240&amp;#34;}, &amp;#34;body&amp;#34;: {&amp;#34;userId&amp;#34;: &amp;#34;lunar-n&amp;#34;}} vegeta.Targeterは func(*vegeta.Target) error である。
また、vegeta.Attackは、vegeta.Targeterをgoroutineで都度呼び出して、Targeter内からTargetに基づきリクエストしていることから、都度Targetが変わるようなTargeterを返す関数を作成し、それをAttack時に呼び出せば良さそう。
ってことが、 [QUESTION] Sending requests with dynamic body #330に書いてあって何度も行き来した結果やっと理解できた&amp;hellip;。
上記を拝借して以下のようにすることで目的を達成できた。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 type yourRequestBody struct { UserID string } targeter := func(id uint64) vegeta.</description>
    </item>
    
    <item>
      <title>Custome Logger using LoggerWithConfig in Echo</title>
      <link>https://lunarxlark.github.io/articles/20201110_echo-custom-logger/</link>
      <pubDate>Tue, 10 Nov 2020 02:51:09 +0900</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20201110_echo-custom-logger/</guid>
      <description>WebFramework EchoのLoggerを弄っていて気付いた点があったのでメモ。
sample code
箇条書き responseログにHeader X-Any-Headerを出力したい場合、ログフォーマットに&amp;quot;any_header&amp;quot;:${header:x-any-header}を指定すればいいよ responseログにQueryParamerter ?anyparam=xxxを出力したい場合、ログフォーマットに&amp;quot;any_query&amp;quot;:${query:anyparam}を指定すればいいよ デフォルトで出力されるカラム&amp;rsquo;id&amp;rsquo;はHeader X-Request-Id を指定すると出力されるよ Skipperを設定することで、path毎にログ出力する/しない等を設定出来るよ 1, 2, 3はEchoのそういう機能だってことで特にありません。 4は結構便利だなと思いました。以下のサンプルコードでは、/healthcheckに来た場合とCI/CD等での自動テスト時にはresponseログを出力しないようにする設定例です。
sample 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // Middleware e.</description>
    </item>
    
    <item>
      <title>My Favorite Usage urfave/cli</title>
      <link>https://lunarxlark.github.io/articles/20200206_my-favorite-usage-urfave-cli/</link>
      <pubDate>Thu, 06 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20200206_my-favorite-usage-urfave-cli/</guid>
      <description>&lt;p&gt;参加しているプロジェクトで&lt;code&gt;urfave/cli&lt;/code&gt;を使っている。使い方は&lt;a href=&#34;https://github.com/urfave/cli/blob/master/docs/v2/manual.md#examples&#34;&gt;Example&lt;/a&gt;にあるのと同じ書き方で使っている。
大半のバッチ処理をコマンドとして記述しているので、Exampleの書き方だとだいぶ見辛くなってきた。縦長のコマンド定義とオプション説明で目的の処理を探すのにもページ送りを何度もする。なんとかしたい。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Error &#39;undefined&#39; when go run</title>
      <link>https://lunarxlark.github.io/articles/20200204_how-to-go-run/</link>
      <pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20200204_how-to-go-run/</guid>
      <description>x…motemen/ghqを写経している時、 go run main.go 出来ないことに気付いた。 下記が実行時のエラーになる。ちなみに、 go build は出来る。
1 2 3 4 ~/d/s/g/x/ghq &amp;gt;&amp;gt;&amp;gt; go run main.go # command-line-arguments ./main.go:38:17: undefined: commands ~/d/s/g/x/ghq &amp;gt;&amp;gt;&amp;gt; commands が見つからない？同じ階層の commands.go には下記記述がちゃんとあるのに、どうして見つからない&amp;hellip;。
1 2 3 4 5 6 var commands = []*cli.Command{ commandGet, commandList, commandRoot, commandCreate, } 理由は、go runの引数に指定したファイル(+ importされるパッケージ)しか読み込まないから。
実際、go run main.go commands.goに変更すると上記エラーは解消される&amp;hellip;が、別のエラーとなる。 今度は違うのが見つからないって言われる。
1 2 3 4 5 6 ~/d/s/g/x/ghq master &amp;gt;&amp;gt;&amp;gt; go run main.go commands.go # command-line-arguments ./commands.go:25:10: undefined: doGet .</description>
    </item>
    
  </channel>
</rss>
