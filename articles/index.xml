<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Articles on /home/lunarxlark/.config/blog</title>
    <link>https://lunarxlark.github.io/articles/</link>
    <description>Recent content in Articles on /home/lunarxlark/.config/blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 10 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://lunarxlark.github.io/articles/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>hashicorp-forge/hermes</title>
      <link>https://lunarxlark.github.io/articles/20230211_hermes/</link>
      <pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20230211_hermes/</guid>
      <description>hashicorp-forge/hermes 触ってみた 2023/02/01 の朝、面白いツイートが目に飛び込みました。
Excited to see the HashiCorp document management system become open source! Built on top of Google Workspaces, this has really helped our writing system scale better with the company instead of pure Drive + Groups. https://t.co/7SUrogij0k pic.twitter.com/v8lkbgjL08
&amp;mdash; Mitchell Hashimoto (@mitchellh) January 31, 2023 ここ半年、いや 1 年位、いやもっとだったかも。設計工程の進め方にずっと不満がありました。
クラウドストレージに散らばっている 見たか見てないのかわからない、コメントへの反応 バージョン管理されていない そんな不満、いや設計構成に一石投じているように感じました。まるで初めて Packer や golps(現 gopls) に出会ったような時の衝撃が走りました。
私はブランクがあるものの、新卒から現在まで IT 業界にいて、設計書を印刷してマーカーを引いたり、ソースコード管理の自前ソフトを使用したライブラリ管理(通称リブ管)をしていた頃もあります。
それに比べたら、今では信じられないくらい進化しています。CVS や CSV ホスティングサービス、Google Sheet には編集履歴や版を設定出来たり。
そんな私にはまさに夢のツールになり得るプロダクトに見えました。ということで、早速動かしました。</description>
    </item>
    
    <item>
      <title>Neovim &#43; DAP &#43; Go</title>
      <link>https://lunarxlark.github.io/articles/20211124_nvim-dap-go/</link>
      <pubDate>Wed, 24 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20211124_nvim-dap-go/</guid>
      <description>TL;DR DAP(Debug Adapter Protocol)の力を借りれば、Neovim上でも視覚的にGoのデバッグが出来ました。 ここでは下記については話しません。
DAPの詳細 packer.nvimでのインストール方法 vscode-goのdebugAdapter.jsの使用方法 Neovimでデバッグするモチベーション v0.2.2から色々変わったNeovimを久々に触ってみようかと思いinit.luaへ以降して遊んでいました。 起動が早いだけでなく、LSP系の動作もサクサク動いてここ2ヶ月程快適に過ごしています。
ただ、VSCodeでのデバッグ機能がとても便利なため、デバッガ使用時のみこの快適な環境を離れていました。
どうにかNeovim上で完結させられないか&amp;hellip;。
DAP DAPの説明はリンク先や他HPをご参照ください。
イメージを持ってもらうためLSPを引き合いに出すと、LSPがテキスト編集時に定義や変更内容や補完候補等を返すのに対して、DAPはデバッガとやりとりしてデバッグ情報を返す位のイメージを持ってもらえれば大丈夫だと思います。
Neovim + DAP + Go 使うプラグインは下記になります。
mfussenegger/nvim-dap : NeovimのDAPクライアント。VSCodeのlaunch.jsonも使用可 rcarriga/nvim-dap-ui : nvim-dapを視覚的に操作しやすいUI leoluz/nvim-dap-go : DAPのGo用設定(delve dap起動) nvim-treesitter/nvim-treesitter nvim-dap-goでテストをデバッグする際、近くのテストを見つけるのに必要 packer.nvimの設定 VSCodeのlaunch.jsonを使用しない場合、require(&#39;dap.ext.vscode&#39;).load_launchjs()は不要です。 launch.jsonを読み込めた場合、デバッグ方法の選択時にlaunch.jsonの内容が追加表示されて選択可能になります。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 -- dap plugin installation with packer.nvim ... -- dap use { &amp;#34;rcarriga/nvim-dap-ui&amp;#34;, requires = { &amp;#34;mfussenegger/nvim-dap&amp;#34;, &amp;#34;leoluz/nvim-dap-go&amp;#34;, &amp;#34;nvim-treesitter/nvim-treesitter&amp;#34; }, config = function () vim.</description>
    </item>
    
    <item>
      <title>gin &#43; gorm v2でのセッションやトランザクション</title>
      <link>https://lunarxlark.github.io/articles/20210912_gin_gormv2/</link>
      <pubDate>Sun, 12 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20210912_gin_gormv2/</guid>
      <description>TL;DR ginでの各リクエストを1セッションで管理しつつ、トランザクションも管理したい。
ginのmiddlewareで、gin.Contextにgorm.WithContextを用いてGormのセッションを持たせる。 ginの各HandlerFuncの中では、gin.Context内のGormセッションからDBへアクセスする。 モチベーション Gormはv2になり色々と変わった。 Gorm 2.0 Release Note
色々な記事が書かれているがTransactoinに関してあまり書かれていない。
下記疑問を払拭して正しい使い方を自分なりに確かめたかったので試した。
なんとなく動くがこれで正しいのか? ドキュメントを読んでいてSkipDefaultTransaction:trueだと30%もパフォーマンスが上がるというがその設定はtrueにしていいいのか? っていうか、DefaultTransactionって何？ロールバックの単位とかどうやって指定するの? 確認&amp;amp;検証 検証時に作成したソースはgithub.com/lunarxlark/gorm2-tx
Context Gorm 2.0 #Context
GormはContextサポートを提供し、それを使いたかったらWithContext使ってくれ。 また、Sessionには単セッションモードと継続セッションモードがある。 普通は、継続セッションモードを使って、複数オペレーションをまとめるよ。 &amp;hellip;GormのSessionってどんなことできるの?
Session Gorm 2.0 #Session
Gormは`Session`メソッドをを通して、新しいセッションを提供するよ。 新しいセッションを作る場合、設定がたくさんあるよ。DryRunやLoggerとかね。 &amp;hellip;新しいセッションを一々作るのは望んでない。
Contextサポートしてくれるってことなのでgin.Contextへ埋め込む時にセッションを作成してそれを使い回したい。
gorm.WithContextのreturnはdb.Sessionとなっている(下記はgormのソースから抜粋)ので、gin.Contextへ埋め込むだけで新たにセッションを作る必要はない。
1 2 3 4 // WithContext change current instance db&amp;#39;s context to ctx func (db *DB) WithContext(ctx context.Context) *DB { return db.Session(&amp;amp;Session{Context: ctx}) } ここまでで下記みたいな感じになる。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 func main() { //.</description>
    </item>
    
    <item>
      <title>ISUCON11予選に参加して惨敗した</title>
      <link>https://lunarxlark.github.io/articles/20181209_isucon11-qualify/</link>
      <pubDate>Sun, 22 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20181209_isucon11-qualify/</guid>
      <description>結果 ISUCON 経験者の 2 名(@Aki_Mineo, @annkara)に誘われてチーム:コバミネとして参加しました。 私は主にインフラ担当でしたが、業務でバックエンドを Go で書いているためインフラの作業を終え次第、合流する作戦でした。
結果は 151 位 29614 点 でした。
悔しい。あそこで気付いていれば&amp;hellip;みたいなポイントがクリティカルでした。
反省点 直すところはたくさんあったと思いますが、直すと決断するまでに迷いがありました。
時間内でのアプリケーションへの理解が足りなかった。 ユーザストーリの理解と加点の仕組みが結びつかなかった。 アプリケーションのどこを直したらいいか。 どう直したら加点されるのか。 非効率なポイントがあっても、他の要因ですぐに直せなそうだった。 見つけた時には時間が足りなかった。 修正して試す環境が本番環境のみだった。 大幅な修正をして、他メンバーとコンフリクトが起きるのが怖かった。 ざっくりタイムライン 前準備
private な作業リポジトリ(メンバーを招待) Discord との webhook deploy.sh 各種 tool のインストールスクリプト 10:00
競技スタート。 @annkaraが AWS アカウントを準備してくれたので CFn でスタック作成。 CFn でのインフラ作成完了。 ssh config 配布。全員が接続確認完了。 初回ベンチ回す。ベンチ:2981点 ソースや設定を GitHub へ。 conditionLimit : 20 -&amp;gt; 40。ベンチ:1704点(すぐ Revert) alp, netdata, pt-query-digest をインストール。 11:00
AP の負荷があまりにも高く、CPU100%に張り付いていたので DB を No.3 へ逃がす。ベンチ:8267点 POST /api/condition を bulk insert へ。ベンチ:9452点 nginx のログ出力を ltsv へ。 mariaDB のスロークエリを出力。 DB table isu_conditionのjia_isu_uuidへ INDEX 追加。ベンチ:22746点 DB table isuのjia_isu_uuidへ INDEX 追加。ベンチ:22492点 12:00</description>
    </item>
    
    <item>
      <title>EC2へssh with GitHubに登録している公開鍵</title>
      <link>https://lunarxlark.github.io/articles/20210704_ssh-with-publickey-without-pem/</link>
      <pubDate>Sun, 04 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20210704_ssh-with-publickey-without-pem/</guid>
      <description>isuconの練習時にGitHubに登録している公開鍵でEC2へssh出来るように、userdataを設定したかった。
sedでのエスケープの仕方でハマったのでメモ。
#!/bin/bash su isucon -c &amp;#39;mkdir -p /home/isucon/.ssh &amp;amp;&amp;amp; touch /home/isucon/.ssh/authorized_keys&amp;#39; su isucon -c &amp;#34;curl https://api.github.com/users/{{github_user_id}}/keys | grep \&amp;#34;key\&amp;#34; | sed -e &amp;#39;s/ \&amp;#34;key\&amp;#34;: \&amp;#34;//g&amp;#39; -e &amp;#39;s/\&amp;#34;//g&amp;#39; &amp;gt;&amp;gt; /home/isucon/.ssh/authorized_keys&amp;#34; </description>
    </item>
    
    <item>
      <title>2021年版 vim &#43; goplsの設定</title>
      <link>https://lunarxlark.github.io/articles/20210616_2021vim_gopls/</link>
      <pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20210616_2021vim_gopls/</guid>
      <description>goplsが出てから, vimでも定義ジャンプやシンボル検索、ドキュメント参照等が行えるようになった。
たまにVSCodeを触りvimでの作業を改善できないか考える中で、自身の設定が古いことに気付いた。また、ググってもなかなか出てこなかったのでメモとして記述する。
cf. GitHub dotfiles
いきなりだが、vimrcとvim-lsp-settings/settings.jsonを抜粋して貼り付ける。
以前、GoではLspCodeAction, LspCodeLens等をサポートしていなかったが、今では使えるようになっている。
キーマップに設定している関数は全てGoで使用出来る。
ただし、カーソルがどこにいても実行出来るわけではないので注意が必要。
LspCodeActionはカーソルの位置によって実行内容が変わるのでそこも注意。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 ... Plug &amp;#39;prabirshrestha/vim-lsp&amp;#39; Plug &amp;#39;mattn/vim-lsp-settings&amp;#39; Plug &amp;#39;prabirshrestha/asyncomplete-lsp.vim&amp;#39; Plug &amp;#39;mattn/vim-gomod&amp;#39; ... &amp;#34; ------------------------------------------------------------------------------ &amp;#34; vim-lsp &amp;#34; ------------------------------------------------------------------------------ function! s:on_lsp_buffer_enabled() abort setlocal omnifunc=lsp#complete setlocal signcolumn=yes if exists(&amp;#39;+tagfunc&amp;#39;) | setlocal tagfunc=lsp#tagfunc | endif nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;ac &amp;lt;plug&amp;gt;(lsp-code-action) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;cl &amp;lt;plug&amp;gt;(lsp-code-lens) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;df &amp;lt;plug&amp;gt;(lsp-definition) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;dd &amp;lt;plug&amp;gt;(lsp-document-diagnostics) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;im &amp;lt;plug&amp;gt;(lsp-implementation) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;pdf &amp;lt;plug&amp;gt;(lsp-peek-definition) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;sm &amp;lt;plug&amp;gt;(lsp-document-symbol-search) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;Sm &amp;lt;plug&amp;gt;(lsp-workspace-symbol-search) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;rf &amp;lt;plug&amp;gt;(lsp-references) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;td &amp;lt;plug&amp;gt;(lsp-type-definition) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;rn &amp;lt;plug&amp;gt;(lsp-rename) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;en &amp;lt;plug&amp;gt;(lsp-next-error) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;ep &amp;lt;plug&amp;gt;(lsp-previous-error) nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;ho &amp;lt;plug&amp;gt;(lsp-hover) let g:lsp_format_sync_timeout = 500 autocmd!</description>
    </item>
    
    <item>
      <title>load test with dynamic payload by tsenart/vegeta</title>
      <link>https://lunarxlark.github.io/articles/20210311_vegeta-dynamic-payload/</link>
      <pubDate>Thu, 11 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20210311_vegeta-dynamic-payload/</guid>
      <description>負荷テストツールvegetaのコマンドでの使い方ぐはググるとたくさん出てくるが、ライブラリとして仕様している記事が少なく手こずったのでメモ代わりに記事にする。
やりたいこと リクエスト毎にRequestの内容を動的に変えて、負荷をかけたかった。
Headerに持つタイムスタンプがリクエスト時のタイムスタンプになるように。 userIdはuniqueになるように。(同じユーザだと重複リクエストを弾く処理があったため。) 具体的には下記のような感じでリクエストを送りたい。
1 2 3 4 5 {&amp;#34;header&amp;#34;: {&amp;#34;timestamp&amp;#34;:&amp;#34;1234&amp;#34;}, &amp;#34;body&amp;#34;: {&amp;#34;userId&amp;#34;: &amp;#34;lunar-1&amp;#34;}} {&amp;#34;header&amp;#34;: {&amp;#34;timestamp&amp;#34;:&amp;#34;1234&amp;#34;}, &amp;#34;body&amp;#34;: {&amp;#34;userId&amp;#34;: &amp;#34;lunar-2&amp;#34;}} {&amp;#34;header&amp;#34;: {&amp;#34;timestamp&amp;#34;:&amp;#34;1235&amp;#34;}, &amp;#34;body&amp;#34;: {&amp;#34;userId&amp;#34;: &amp;#34;lunar-3&amp;#34;}} ... {&amp;#34;header&amp;#34;: {&amp;#34;timestamp&amp;#34;:&amp;#34;1240&amp;#34;}, &amp;#34;body&amp;#34;: {&amp;#34;userId&amp;#34;: &amp;#34;lunar-n&amp;#34;}} vegeta.Targeterは func(*vegeta.Target) error である。
また、vegeta.Attackは、vegeta.Targeterをgoroutineで都度呼び出して、Targeter内からTargetに基づきリクエストしていることから、都度Targetが変わるようなTargeterを返す関数を作成し、それをAttack時に呼び出せば良さそう。
ってことが、 [QUESTION] Sending requests with dynamic body #330に書いてあって何度も行き来した結果やっと理解できた&amp;hellip;。
上記を拝借して以下のようにすることで目的を達成できた。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 type yourRequestBody struct { UserID string } targeter := func(id uint64) vegeta.</description>
    </item>
    
    <item>
      <title>2020年 ふりかえり</title>
      <link>https://lunarxlark.github.io/articles/20201229_2020-summary/</link>
      <pubDate>Tue, 29 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20201229_2020-summary/</guid>
      <description>2020年の振り返りと来年にやりたいことをつらつらと書こうと思う。 きっかけは、1on1をしてくれたEMからのアドバイスだ。
年末になると、1年を振り返るが過小評価しがち 何回かに分けてやると良い 謙遜せずやったことはやったと自分に言う そんな趣旨のアドバイスを貰った。実際、いつも自分でやる振り返りでは、今年も結局&amp;hellip;みたいな評価になってしまっている。 仕事を頑張っていないわけではない。今年は自分でも頑張ったと思う。そんな、いつもは謙虚な(?)な自分に今年は前向きな評価をしてあげよう。 そう思った。
Dependency Injectionの実装方法を理解した トランザクションマネージャ(DB参照先を捕捉し、rollbackを埋め込んであるmethodを持つinterface)を依存性に注入することでrollback記載不要に。 トップダウンで記述するDIでは、DB参照先もあらかじめ記述しておけるが、トランザクション範囲については自身で記載しなければ出来ないという結論に。 ポインタレシーバにはポインタが、値レシーバには値がコピーされる。 メソッドをinterfaceに指定する際、レシーバにコピーされる値への変更を保持したいか等でポインタ/値レシーバどちらにするかの判断基準になる。 WebFramework Echoのmiddlewareの作り方。 Skipperによるecho.Contextの使い回し方。(structメンバーに、echo.Contextを引数に持つ関数を持たせる) Echoのデフォルトログでは、ヘッダーx-request-idに指定した値がrequest idに出る。 Echoのmiddlewareに対する理解が深まった。(雑) CloudFrontの各項目に対する理解が深まり、通信障害時にどのように調べて、どのメトリクスを見れば良いかがある程度わかるようになった。 CloudFrontのrequest idをoriginのEchoへ出力したい場合、x-amz-cf-idをEchoロガーで出力すればよい。 L@Eの使い方と開発/リリース時の注意点について教訓を得た。 L@Eへの反映には時間がかかるので、テストの仕方を工夫しなければいけない。 L@Eに適用するLambdaのversionはLATESTを指定出来ないので、リリース時にはLambdaのversionを数値指定しなければいけない。 L@Eを修正するにあたり、Node.js v10.xを少し勉強した。(動的型付け言語は好きになれない。結局、undefinedと向き合わなければならず、動的型付けのメリットが感じられなかった。) その点、TypeScriptはちょっと触った感じ楽しかった。トランスパイルという言葉を知った。(言語のversionがどんどん上がっていくECMAScriptに対して、トランスパイルが追従していけるのかちょっと不安を感じた。) AWS StepFunctionは、Lambdaをjsonというインタフェースで繋げていて、Lambdaのフローをjsonで定義しているだけなんだと理解した。 AWS Lambdaをローカルである程度動作確認出来るようにDEBUGフラグを付けた。 Go言語の開発環境が自分の中で固まってきた。(Vimで必要なPluginがある程度固定されてきた) Alfredにより、unixtimestamp変換とbase64エンコード/デコードが素早く行えるようになった。 CI/CD時にdocker pull rate limitによるエラーを、DockerHubへのログインで解消させた。 コネクションプールの生存時間が短すぎることを見つけ、DBstatsからコネクションスパイクに対してプール生存時間を伸ばすことでDBへの負荷とコネクション接続時のlatencyを短くした。 </description>
    </item>
    
    <item>
      <title>Custome Logger using LoggerWithConfig in Echo</title>
      <link>https://lunarxlark.github.io/articles/20201110_echo-custom-logger/</link>
      <pubDate>Tue, 10 Nov 2020 02:51:09 +0900</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20201110_echo-custom-logger/</guid>
      <description>WebFramework EchoのLoggerを弄っていて気付いた点があったのでメモ。
sample code
箇条書き responseログにHeader X-Any-Headerを出力したい場合、ログフォーマットに&amp;quot;any_header&amp;quot;:${header:x-any-header}を指定すればいいよ responseログにQueryParamerter ?anyparam=xxxを出力したい場合、ログフォーマットに&amp;quot;any_query&amp;quot;:${query:anyparam}を指定すればいいよ デフォルトで出力されるカラム&amp;rsquo;id&amp;rsquo;はHeader X-Request-Id を指定すると出力されるよ Skipperを設定することで、path毎にログ出力する/しない等を設定出来るよ 1, 2, 3はEchoのそういう機能だってことで特にありません。 4は結構便利だなと思いました。以下のサンプルコードでは、/healthcheckに来た場合とCI/CD等での自動テスト時にはresponseログを出力しないようにする設定例です。
sample 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // Middleware e.</description>
    </item>
    
    <item>
      <title>New Github Official CLI `gh`</title>
      <link>https://lunarxlark.github.io/articles/20200214_new-github-command-gh/</link>
      <pubDate>Fri, 14 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20200214_new-github-command-gh/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/cli/cli/cmd/gh&#34;&gt;github.com/cli/cli/cmd/gh&lt;/a&gt; is new official command for GitHub.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>From denite.nvim To fzf.vim</title>
      <link>https://lunarxlark.github.io/articles/20200211_from-denite-to-fzf/</link>
      <pubDate>Tue, 11 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20200211_from-denite-to-fzf/</guid>
      <description>denite.nvimとfzf.vimって比較記事?
違います。断捨離した結果、fzf.vimで事足りてしまったという記事です。
denite.nvimとfzf.vimは、一見やれることが似ているように見えますが提供しているインタフェースが違います。 denite.nvimの方が拡張性/汎用性が高いです。Pythonスクリプトを呼び出せますし。
どうしてやめたん？
Python3とpipの環境整備に疲れたというのが理由で完全に力不足なだけです。
そもそも使いこなせていなかったっていうのも大きい。自分に必要な機能が何か見直したら次のがあれば十分っぽい。
コマンドの結果の一覧表示(x-motemen/ghq list, mattn/memo list, history等) 一覧表示の後のアクションを指定可能(cd, vim) buffer切替 fzf.vimはfzfのついでに入れていただけで全く使っていなかった。Shougo/denite.nvimでfzf.vimで同じことが出来るし、sourceの拡張がいくつもあるのでそれで十分だった。
もともとfzfが好きなのもあって、fzf.vimで上記が実現出来るように設定した、っていうかhelpからパクってきた。
何日か使っていて快適に使えているので結構満足。previewはbatってコマンド入れないとsyntax highlightされなかったのでいれたけど、なんとなくそっちの方がリッチっぽいという理由だけなので重ければそのうち消す。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 command! -bang -nargs=? -complete=dir Files call fzf#vim#files( \ &amp;lt;q-args&amp;gt;, \ fzf#vim#with_preview(), \ &amp;lt;bang&amp;gt;0) command! -nargs=0 Ghq call fzf#run({ \ &amp;#39;source&amp;#39; : &amp;#39;ghq list --full-path&amp;#39;, \ &amp;#39;sink&amp;#39; : &amp;#39;cd&amp;#39; \}) command!</description>
    </item>
    
    <item>
      <title>My Favorite Usage urfave/cli</title>
      <link>https://lunarxlark.github.io/articles/20200206_my-favorite-usage-urfave-cli/</link>
      <pubDate>Thu, 06 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20200206_my-favorite-usage-urfave-cli/</guid>
      <description>&lt;p&gt;参加しているプロジェクトで&lt;code&gt;urfave/cli&lt;/code&gt;を使っている。使い方は&lt;a href=&#34;https://github.com/urfave/cli/blob/master/docs/v2/manual.md#examples&#34;&gt;Example&lt;/a&gt;にあるのと同じ書き方で使っている。
大半のバッチ処理をコマンドとして記述しているので、Exampleの書き方だとだいぶ見辛くなってきた。縦長のコマンド定義とオプション説明で目的の処理を探すのにもページ送りを何度もする。なんとかしたい。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Error &#39;undefined&#39; when go run</title>
      <link>https://lunarxlark.github.io/articles/20200204_how-to-go-run/</link>
      <pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20200204_how-to-go-run/</guid>
      <description>x…motemen/ghqを写経している時、 go run main.go 出来ないことに気付いた。 下記が実行時のエラーになる。ちなみに、 go build は出来る。
1 2 3 4 ~/d/s/g/x/ghq &amp;gt;&amp;gt;&amp;gt; go run main.go # command-line-arguments ./main.go:38:17: undefined: commands ~/d/s/g/x/ghq &amp;gt;&amp;gt;&amp;gt; commands が見つからない？同じ階層の commands.go には下記記述がちゃんとあるのに、どうして見つからない&amp;hellip;。
1 2 3 4 5 6 var commands = []*cli.Command{ commandGet, commandList, commandRoot, commandCreate, } 理由は、go runの引数に指定したファイル(+ importされるパッケージ)しか読み込まないから。
実際、go run main.go commands.goに変更すると上記エラーは解消される&amp;hellip;が、別のエラーとなる。 今度は違うのが見つからないって言われる。
1 2 3 4 5 6 ~/d/s/g/x/ghq master &amp;gt;&amp;gt;&amp;gt; go run main.go commands.go # command-line-arguments ./commands.go:25:10: undefined: doGet .</description>
    </item>
    
    <item>
      <title>aws-cliで始めるCloudFormation</title>
      <link>https://lunarxlark.github.io/articles/20190305_aws-getting-start-cloudformation/</link>
      <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20190305_aws-getting-start-cloudformation/</guid>
      <description>&lt;h4 id=&#34;目的&#34;&gt;目的&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;CloudFormationで使われる用語を理解する&lt;/li&gt;
&lt;li&gt;CloudFormationの構成を理解する&lt;/li&gt;
&lt;li&gt;出来るだけaws-cliのコマンドを実行していく&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>LSP(Language Server Protocol)のドキュメントを読む</title>
      <link>https://lunarxlark.github.io/articles/20190223_read-lsp-doc-overview/</link>
      <pubDate>Sat, 23 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20190223_read-lsp-doc-overview/</guid>
      <description>&lt;p&gt;golangコミュニティが&lt;a href=&#34;https://godoc.org/golang.org/x/tools/cmd/gopls&#34;&gt;gopls&lt;/a&gt;を開発し始めたり、Microsoftが提唱したこともあって&lt;code&gt;Language Server Protocol (以後,LSP)&lt;/code&gt;が注目され始めた。
特にVimやgolang界隈ではmattnさんのブログ記事&lt;a href=&#34;https://mattn.kaoriya.net/software/lang/go/20181217000056.htm&#34;&gt;gocode やめます(そして Language Server へ)&lt;/a&gt;で一層注目を集めたと思う。是非読んで欲しい。
gocode contribuerへの思いとLSP発展への期待が書かれている。&lt;/p&gt;
&lt;p&gt;そんな熱いLSPを理解することでVim発展に拍車がかかることへの期待とgoplsを理解したいという興味から、まずはLSPドキュメントを訳してみた。
実際に、vim-lsp+goplsを入れて、log出力と照らし合わせながらLSPがどういう風に動くものなのか、理解が深まったと思う。以下、ドキュメントの訳。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Javaのチューニングオプション</title>
      <link>https://lunarxlark.github.io/articles/20181202_java-tuning-options/</link>
      <pubDate>Sun, 02 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20181202_java-tuning-options/</guid>
      <description>&lt;h3 id=&#34;options&#34;&gt;Options&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-D&lt;/code&gt;はシステムのオプション&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:&lt;/code&gt;はJava Hotspot VMのオプション &lt;a href=&#34;https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html&#34;&gt;# Optinos_list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-XX:&lt;/code&gt;オプションに対して、&lt;code&gt;+&lt;/code&gt;で有効、&lt;code&gt;-&lt;/code&gt;で無効を表す。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>ansibleでの各roleのパス取得方法</title>
      <link>https://lunarxlark.github.io/articles/20181015_ansible-how-to-get-role-path/</link>
      <pubDate>Mon, 15 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20181015_ansible-how-to-get-role-path/</guid>
      <description>&lt;p&gt;playbookをrole毎に分けた際、roleの中でfilesのpath指定をするために実行中の/path/to/role/{current}を知りたくなった。&lt;/p&gt;
&lt;p&gt;ref: &lt;a href=&#34;https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#accessing-information-about-other-hosts-with-magic-variables&#34;&gt;Accessiing information about other hosts with magic variables&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Ansibleでよく使うモジュール</title>
      <link>https://lunarxlark.github.io/articles/20180930_ansible-useful-modules/</link>
      <pubDate>Sun, 30 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20180930_ansible-useful-modules/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Gemfileの書き方</title>
      <link>https://lunarxlark.github.io/articles/20180928_gem-gemfile-format/</link>
      <pubDate>Fri, 28 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20180928_gem-gemfile-format/</guid>
      <description>&lt;p&gt;Rails公式ドキュメントからGemfileの書き方を抜粋&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>aws-cliの結果をJMESPathで取得する方法</title>
      <link>https://lunarxlark.github.io/articles/20180610_aws-getting-info-from-awscli-with-jmespath/</link>
      <pubDate>Sun, 10 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20180610_aws-getting-info-from-awscli-with-jmespath/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;tagやownerでfilterして、作成日でソートした結果のうちImageIdだけ取り出す&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>AuroraのUpgradeでの注意点</title>
      <link>https://lunarxlark.github.io/articles/20180503_aws-important-notice-aurora-upgrade/</link>
      <pubDate>Thu, 03 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://lunarxlark.github.io/articles/20180503_aws-important-notice-aurora-upgrade/</guid>
      <description>&lt;p&gt;Auroraのアップグレードには何種類かあり、それぞれでダウンタイム有無やパッチ適用時間が異なる。
アップグレードの種類と気にしなければいけないことをまとめた。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
